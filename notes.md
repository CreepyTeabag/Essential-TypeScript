# Глава 2. Ваше первое приложение на TypeScript
## 2.2
### 2.2.3
Чтобы запустить компилятор, который сам преобразует файлы по правилам, указанным в `tsconfig.json`, нужно просто в соответствующей папке выолнить команду `tsc`.
### 2.2.4
Чтобы выполнить скомпилированный код в консоли, нужно выполнить `node path/to/file.js`.
### 2.2.6
Форма объекта - это комбинация свойств объекта и типов их значений.
Структура типа - конкретная комбинация имён и  типов.
Ключевое слово `type` используется для создания псевдонима типа (это удобный способ присвоения имени структуре типа).

## 2.3
### 2.3.1
Для того, чтобы использовать в проекте пакеты в формате модулей ECMAScript, нужно указать в package.json `"type": "module"`, а в импортах нужно прописать расширения файлов, при чём указывать нужно именно .js файлы.
### 2.3.3 
Многие пакеты поставляются в виде чистого JavaScript, но с этим может помочь проект Definitely Typed, - это репозиторий деклараций типов для многих пакетов JavaScript.

# Глава 3. Обзор JavaScript, часть 1
## 3.3
### 3.3.1 
Во многих языках программирования для переменной нужно указать её тип. В JavaScript же типы имеют значения, а не переменные.
В JavaScript есть известный баг: команда `typeof null` возвращает `object`.
### 3.3.2
При абстрактном сравнении равенства (x == y) если `x: number`, а `y: string`, то `y` будет сначала приведён к типу `number`, а затем будет выполнено сравнение.
При этом при сложении двух переменных, если одна из них - строка, то вторая тоже приводится к строке и производится конкатенации.
### 3.3.3
Параметр rest (`...`) в функции `function test (a,b, ...other) {}` - это массив, содержащий все аргументы, для которых параметры не были определены.
Стрелочные функции также иногда называют функциями толстых стрелок или лямбда-выражениями.
### 3.4.2.
Деструктуризация массива:
```
let names = ["Hat", "Boots", "Gloves"];
let [one, two] = names; // one = "Hat", two = "Boots"
```

При деструктуризации массива можно игнорировать элементы, просто не указывая их имена в присваивании:
```
let names = ["Hat", "Boots", "Gloves"];
let [, , three] = names; // three = "Gloves"
```
### 3.5.1
Optional chaining operator `obj?.param` по-русски называется оператор опциональной последовательности.

# Глава 4.Обзор JavaScript, часть 2
## 4.2
Объекты JavaScript связаны с другими объектами, известными как прототипы, от которых они наследуют свойства и методы. Поскольку прототипы сами являются объектами и могут иметь свои прототипы, объекты формируют цепочку наследования, что позволяет один раз определить сложные функции и последовательно использовать их.
У объекта, созданного с помощью литерала, прототипов является встроенный в JavaScript `Object`.
### 4.2.1
Полезные методы объектов:
getPrototypeOf - Возвращает прототип объекта
setPrototypeOf - Изменяет прототип объекта
getOwnPropertyNames - Возвращает имена свойств объекта
### 4.2.3
Функция-конструктор используется для создания нового объекта, настройки его свойств и присвоения прототипа, причем все это делается за один шаг с помощью ключевого слова `new`. Функции-конструкторы можно использовать для обеспечения единообразного создания объектов и применения правильного прототипа.

Функции-конструкторы вызываются с помощью ключевого слова `new`, за которым следует имя функции или ее переменной и аргументы, которые будут использоваться для конфигурирования объекта, например, так: `let hat = new Product("Hat", 100);`

Среда выполнения JаvаSсriрt создает новый объект и использует его в качестве значения `this` для вызова функции-конструктора, предоставляя значения аргументов в качестве параметров. Функция-конструктор может настраивать свойства объекта с помощью ключевого слова `this`, которое установлено для нового объекта.
```
let Product = function(name, price) {
   this.name = name;
   this.price = price;
}
```

Прототипом нового объекта устанавливается объект, возвращаемый свойством `prototype` функции-конструктора. Это приводит к тому, что конструкторы определяются в двух частях: сама функция применяется для настройки свойств объекта, а объект, возвращаемый свойством `prototype`, используется для свойств и методов, которые должны быть общими для всех объектов, создаваемых конструктором. В листинге к прототипу функции-конструктора `Product` добавлено свойство `toString` для определения метода:
```
Product.prototype.toString = function() {
   return `toString: Name: ${this.name}, Price: ${this.price}`;
}
```
### 4.2.5
Оператор `instanceof` используется для проверки того, входит ли прототип конструктора в цепочку прототипов конкретного объекта.
### 4.2.6
Свойства и методы, определяемые в функции-конструкторе, часто называют статическими, то есть доступ к ним осуществляется через конструктор, а не через отдельные объекты, созданные этим конструктором (в отличие от свойств экземпляра, доступ к которым осуществляется через объект). Примерами статических методов являются методы `Object.setPrototypeOf` и `Object.getPrototypeOf`.